<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[categories: SCM | 折腾来折腾去]]></title>
  <link href="http://pikipity.github.com/blog/categories/scm/atom.xml" rel="self"/>
  <link href="http://pikipity.github.com/"/>
  <updated>2013-01-30T00:00:00+08:00</updated>
  <id>http://pikipity.github.com/</id>
  <author>
    <name><![CDATA[pikipity]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[单片机原理及程序设计 第二章 记忆体和寄存器]]></title>
    <link href="http://pikipity.github.com/blog/scm-principle-2.html"/>
    <updated>2013-02-27T22:37:00+08:00</updated>
    <id>http://pikipity.github.com/blog/scm-principle-2</id>
    <content type="html"><![CDATA[<p><a href="http://pikipity.github.com/blog/scm-principle-1.html">上一章</a>主要是简单介绍了一下 8051 的样子和结构，这一章主要介绍内存，为将来介绍各个特殊功能和 assembly 做准备。</p>

<h3 id="section">记忆体种类</h3>

<p>记忆体主要分为两种：</p>

<ol>
  <li>只读记忆体（ROM）：资料一旦存储就不能删除或是修改（既不能重新写入），且内容不会因为断电而消失。一般来说，我们可以认为你所编写的程式就存储在 8051 的 ROM 中，当然现在的新科技已经允许通过一定的手段来从新修改 ROM 上的内容了，所以你可以向你的 8051 芯片中重新写入程式，但是重新写入的次数是有限，但是这个次数非常大，所以不用担心。8051 内部 ROM 容量为 4K Byte，最大可扩充到 64K Byte。8052 内部 ROM 容量为 8K Byte，最大可扩充到 64K Byte</li>
  <li>随即存储存储器（RAM）：可以随时将数据存入记忆体的任意位置，但是断电后数据会消失。一般来说，我们可以认为程式临时数据就是存储在 8051 的 RAM 中的。8051 内部 RAM 容量为 128 Byte，最大可扩充到 64K Byte。8052 内部 RAM 容量为 256 Byte，最大可扩充到 64K Byte。</li>
</ol>

<!--more-->

<h3 id="section-1">地址分配</h3>

<p>我们不可能随意的将数据存储在记忆体中，如果那样的话，我们就难以知道自己所需的数据到底存储在哪里，所以我们用“地址”来对记忆体中的数据定位。我们一般用一个十六进制数<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 来表示一个地址。程式记忆体（可以理解为 ROM）和资料记忆体（可以理解为 RAM）的地址是分开的。</p>

<ol>
  <li>程式记忆体地址分配：由于 8051 允许外部扩充程式记忆体，所以程式记忆体的地址分配有两种（以下程式记忆体的地址都是一个地址代表一个字节（8位二进制））：
    <ul>
      <li>
        <p>EA 引脚接高时：</p>

        <p><img src="/images/post/scm-principle-2-1.jpg" alt="当 EA 接高时，程式记忆体的地址分配" width="350pt" /></p>
      </li>
      <li>
        <p>EA 引脚接地时：</p>

        <p><img src="/images/post/scm-principle-2-2.jpg" alt="当 EA 接地时，程式记忆体的地址分配" width="350pt" /></p>
      </li>
    </ul>
  </li>
  <li>资料记忆体地址分配：资料记忆体的地址（依然是一个地址代表一个字节（8位二进制））从 00H 到 FFH，共分为四个部分：
    <ul>
      <li>
        <p>00H ~ 1FH：四个寄存器组。由于在写 assembly 程序的时候，每次都记住地址很麻烦，所以 assembly 为一部分地址直接预设了名字，这样我们就可以直接通过调用名字来使用这一部分内存而不是记住地址。这四个寄存器组 RB0~RB3 中，每个寄存器组又包含8个8位寄存器 R0~R7（每个字节地址就是一个寄存器），主要用来存放数据。但每次只能使用一个寄存器组，通过 RS0 和 RS1 两个位元来控制到底使用哪个寄存器组：</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: center">RS1</th>
              <th style="text-align: center">RS0</th>
              <th style="text-align: center">寄存器组</th>
              <th style="text-align: center">位置</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center">0</td>
              <td style="text-align: center">0</td>
              <td style="text-align: center">RB0</td>
              <td style="text-align: center">00H~07H</td>
            </tr>
            <tr>
              <td style="text-align: center">0</td>
              <td style="text-align: center">1</td>
              <td style="text-align: center">RB1</td>
              <td style="text-align: center">08H~0FH</td>
            </tr>
            <tr>
              <td style="text-align: center">1</td>
              <td style="text-align: center">0</td>
              <td style="text-align: center">RB2</td>
              <td style="text-align: center">10H~17H</td>
            </tr>
            <tr>
              <td style="text-align: center">1</td>
              <td style="text-align: center">1</td>
              <td style="text-align: center">RB3</td>
              <td style="text-align: center">18H~1FH</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>20H ~ 2FH：可位元寻址区，这一部分的地址都允许直接对 bit 进行操作。例如，21H.0 就代表在字节地址 21H 的8位二进制的第 0 位。</li>
      <li>30H ~ 7FH：一般数据与堆栈区。不可以位元寻址，就是一般的存储数据的地方</li>
      <li>
        <p>80H ~ FFH：特殊功能寄存器（SFR）。8051 本事已经内置了很多的功能，在<a href="http://pikipity.github.com/blog/scm-principle-1.html">第一章</a>的8051单片机结构中就可以看到，有计时/计数器、中断、UART串口等等，这些特殊功能需要通过设置这一部分的 SFR 的参数来控制。在讲解各个特殊功能的时候会讲解如何设置参数，和这些参数代表什么意思。下面是一幅AT89系列的 SFR 地址分配表，将来可以对照、理解。</p>

        <p><img src="/images/post/scm-principle-2-3.jpg" alt="AT89系列的 SFR 地址分配表" width="550pt" /></p>

        <p>注意：</p>

        <ul>
          <li>注意最左边一列都可以位元寻址</li>
          <li>括号中的寄存器代表 AT89C52 才有，AT89C51 没有</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>十六进制数就是以逢16进1作为进位制的数，一般用数字0到9和字母A到F表示，并在数后面加一个“H”来表示此数为16进制。<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Proteus和Keil的简单教程]]></title>
    <link href="http://pikipity.github.com/blog/keil-and-proteus.html"/>
    <updated>2013-02-16T21:38:00+08:00</updated>
    <id>http://pikipity.github.com/blog/keil-and-proteus</id>
    <content type="html"><![CDATA[<p>这篇主要简单介绍一下单片机仿真软件Proteus和单片机编程软件Keil，方便各位读者能够快速的在自己电脑上搭建一个8051单片机的软件仿真平台。</p>

<h3 id="proteus">单片机仿真软件 – Proteus</h3>

<p>如果你在平时的电路仿真中稍微留意一下的你会发现<a href="http://baike.baidu.com/view/1867313.htm">Spice</a>在仿真中都无法仿真单片机系统，所以这里需要介绍一下这个单片机仿真软件<a href="http://baike.baidu.com/view/40936.htm">Proteus</a>。由英国<a href="http://www.labcenter.com/index.cfm">Labcenter electronics公司</a>出品的<a href="http://baike.baidu.com/view/5822.htm">EDA软件</a>，可以很好的仿真一部分单片机及其外围器材。并具有自动布线和智能生成原理图的功能。</p>

<!--more-->

<p>大家可以到<a href="http://pan.baidu.com/share/link?shareid=345198&amp;uk=4080321956">这里</a>下载Proteus Pro v7.8，压缩包内带有序列号生成器，并有安装及破解说明文件，虽然版本比较老，但是亲测可用。</p>

<p>下载并安装完成后，点击<img src="/images/post/proteus.png" width="50pt" />打开ISIS仿真软件，界面如下</p>

<p><img src="/images/post/proteus_1.jpg" alt="Proteus仿真界面" width="650pt" /></p>

<p>接下来介绍几点比较重要的使用方法，如果想要更详细一点的教程的话，可以到<a href="http://pan.baidu.com/share/link?shareid=354817&amp;uk=4080321956">这里</a>下载</p>

<ol>
  <li>
    <p>添加元件方法：在图纸范围内单机鼠标右键，打开菜单，”Place”中就是可以放置的元件。单片机及外围元件在Component -&gt; From Libraries中搜索就可以了。</p>

    <p><img src="/images/post/proteus_menu.jpg" alt="右键菜单" width="300pt" /></p>

    <p><img src="/images/post/proteus_menu_place.jpg" alt="Place菜单" width="450pt" /></p>

    <p><img src="/images/post/library.jpg" alt="Place -&gt; Component -&gt; From Libraries" width="550pt" /></p>

    <p>如果需要电源和地，则从Terminal中选择POWER或是GND就可以了，系统会根据你选则的单片机自动匹配POWER的电压大小（注意仿真的时候单片机本身不用接<a href="/blog/scm-principle-1.html">电源电路和时钟电路</a>），如果需要更改POWER电压值，只要右键单击POWER，选择”Edit Properties”，在”String”中输入你需要的电压值就可以了。</p>

    <p><img src="/images/post/terminal.jpg" alt="Terminal菜单" width="450pt" /></p>

    <p><img src="/images/post/POWER.jpg" alt="右键单击POWER元件" width="400pt" /></p>

    <p><img src="/images/post/POWER_edit.jpg" alt="Edit Properties" width="400pt" /></p>
  </li>
  <li>
    <p>连线方法：连线有三种方法，</p>

    <ul>
      <li>
        <p>直接连线：用鼠标点击两个节点便会自动连接。注意：当端口对齐的时候，只要连好最上面的第一条线，下面的线只要双击节点就可以自动连接，基本原理就是重复你的上一次动作。</p>

        <p><img src="/images/post/direct_connect.jpg" alt="直接连线的效果" width="550pt" /></p>
      </li>
      <li>
        <p>间接连线：通过右键菜单中的Terminal中的INPUT和OUTPUT连结两个节点。注意：对应的IMPUT和OUTPUT需要有一样的名字，起名字的方法和编辑POWER电压值的方法一样。</p>

        <p><img src="/images/post/indirect_connect.jpg" alt="间接连线的效果" width="550pt" /></p>
      </li>
      <li>
        <p>使用BUS连线：在左侧工具栏选择BUS <img src="/images/post/BUS.jpg" width="50pt" />，就可以画出蓝色BUS线了，注意转折的地方需要点一下鼠标，结束双击鼠标。画完BUS线后，将节点连到BUS线上，然后对BUS设置Label,方法是右键单击BUS线，选择“Place Wrie Label”，Label的输入方式类似于下面效果图，意思是生成A1到A3的Label。再将对应节点的连线改为一样的名字，改名字的方法，和BUS线加Label的方法一样。注意：连线的名字不用一个个输入了，由于之前的BUS已经生成了Label，只要在下拉框内选择就可以了。</p>

        <p><img src="/images/post/BUS_connect.jpg" alt="BUS连线效果图" width="550pt" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>向单片机内加载生成的Hex文件的方法：左键双击单片机，在”Program File”一栏里填入Hex文件的路径或点击后面文件夹选择Hex文件，”OK”即可。在这个窗口还可以改变时钟周期，在”Clock Frequency”中修改。</p>

    <p><img src="/images/post/doube_click_scm.jpg" alt="左键双击单片机" width="400pt" /></p>
  </li>
</ol>

<h3 id="keil">51系列单片机编程软件 – Keil</h3>

<p><a href="http://baike.baidu.com/view/942051.htm">Keil</a>是美国<a href="http://www.keil.com/">Keil software公司（已被ARM收购）</a>出品的专为51系列单片机进行编程的软件，可以编译C语言和汇编语言，其C语言的编译器Keil C51已经成为一种类似于行业标准一样的存在了。</p>

<p>可以到<a href="http://pan.baidu.com/share/link?shareid=354882&amp;uk=4080321956">这里</a>下载Keil uVision3，或者到<a href="http://www.doyoung.net/data.html">杜洋工作室</a>下载。</p>

<p>下载并安装后，就可以通过<img src="/images/post/keil.png" width="50pt" />打开了。打开后界面如下图。每次打开都会自动回复上次关闭前最后一次保存的Project。</p>

<p><img src="/images/post/keil_1.jpg" alt="Keil uVision3 界面" width="650pt" /></p>

<p>建立一个Project一般分为如下几步：</p>

<ol>
  <li>
    <p>在菜单栏上选择 Prject -&gt; New Project，并起名字和保存。</p>

    <p><img src="/images/post/new_project.jpg" alt="New Project" width="650pt" /></p>

    <p><img src="/images/post/projectname.jpg" alt="Project起名、保存" width="650pt" /></p>
  </li>
  <li>
    <p>选择单片机类型。注意：确定后，会弹出对话框询问是否自动添加启动文件到Project中，一般选择“No”就可以了，因为由Keil提供的单片机启动文件在初学阶段一般不会用到</p>

    <p><img src="/images/post/scmstyle.jpg" alt="选择单片机类型" width="650pt" /></p>

    <p><img src="/images/post/startup.jpg" alt="是否添加启动文件" width="450pt" /></p>
  </li>
  <li>
    <p>然后新建一个文件开始编写C或者汇编。注意：保存的时候需要提供后缀名，如C的后缀为.c，汇编的后缀为.asm</p>

    <p><img src="/images/post/newfile.jpg" alt="新建文件" width="650pt" /></p>

    <p><img src="/images/post/filename.jpg" alt="保存文件（注意文件名）" width="650pt" /></p>
  </li>
  <li>
    <p>右键单击Project的文件夹，选择”Add Files to Group”，选择你的文件，“OK”，就可以将文件加入到project中</p>

    <p><img src="/images/post/addtogroup.jpg" alt="将文件加入到project中" width="650pt" /></p>
  </li>
  <li>
    <p>编译的时候，只要按工具栏上的<img src="/images/post/buildall.jpg" width="50pt" />就可以编译了。如果需要生成Hex文件用来烧录或是仿真，就需要在编译前按工具栏上的<img src="/images/post/projectproperty.jpg" width="50pt" />，选中”Output”中的”Creat HEX”就可以了。</p>

    <p><img src="/images/post/creathexornot.jpg" alt="生成Hex选项" width="650pt" /></p>
  </li>
</ol>

<p>有了这两个软件，大家就可以进行单片机从硬件到软件的软件仿真了，但是仿真永远是仿真，不代表实物就是如此，所以真正实际是什么样子，还是硬件仿真比较靠谱。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单片机原理及程序设计 第一章 单片机简介]]></title>
    <link href="http://pikipity.github.com/blog/scm-principle-1.html"/>
    <updated>2013-02-08T23:47:00+08:00</updated>
    <id>http://pikipity.github.com/blog/scm-principle-1</id>
    <content type="html"><![CDATA[<p>这个《单片机原理及程序设计》系列主要是简单介绍8051系列单片机的基本原理及功能，并附带一些小程序作为应用的范例，为了便于程序理解，大多程序以C的形式出现，但是也会包括一部分的汇编，因为汇编是用来学习单片机结构与原理的最好语言了。这个系列主要抄录自<a href="http://elearning.stut.edu.tw/mechelec/chip.htm">《單晶片原理與程式設計》</a>，<a href="http://elearning.stut.edu.tw/mechelec/chip.htm">《單晶片原理與程式設計》</a>虽然介绍得已经很全面了，但是由于过于简略，以至于一个新手如果只看这一份材料很难明白它在说什么，所以这里作进一步的归纳、总结和补充。</p>

<h3 id="section">什么是单片机</h3>

<p><img src="/images/post/scm-principle-1_1.png" alt="单片机 AT89C51" width="300pt" /></p>

<!--more-->

<p>上面这幅图就是8051系列的一种单片机AT89C51了，是的，单片机就是一块芯片而已，但是这块芯片里面可以说是包含了大半个你用的PC机或是ipad吧。需要注意的是，下面这幅图是单片机学习板，不要再指着整块学习板说是单片机了，学习板包是一整套完整的电路，包含了你要学习的原件，只要将单片机插入到上面，正确编程就可以使用了，使初学者专注于编程学习，可以忽略掉复杂的电路设计部分。但是单片机的编程是硬件编程（在后面的编程部分你就能深刻的体会到硬件编程和平常的编程有什么不同了），硬件部分的学习是绝对不可以忽略的。所以我建议，学习单片机不要只是编程，有条件，就买实体元件，自己搭建电路，可以学习的更加透彻，没有条件，可以下载仿真程序，例如<a href="http://baike.baidu.com/view/40936.htm">Proteus</a>(<a href="http://pan.baidu.com/share/link?shareid=345198&amp;uk=4080321956">点我下载Proteus</a>)。<a href="http://baike.baidu.com/view/40936.htm">Proteus</a>是一个简单易用的可以仿真单片机系统的软件，里面包含了大部分的8051系列芯片，和大量的常用原件，有了这个“妈妈再也不用花钱给我买学习版了”  o(≧v≦)o~~</p>

<p><img src="/images/post/scm-principle-1_2.png" alt="开发板" width="300pt" /></p>

<p>对单片机有了实感接触以后，就可以开始单片机的学习了</p>

<h3 id="section-1">单片机结构</h3>

<p>这部分其实是废话，因为如果不准备做单片机开发，太过深入了解单片机结构根本就没有什么用，但是话又说回来，如果一点都不了解的话，对于初学者心里又不踏实，总而言之还是需要了解的，仅仅是了解而已。</p>

<p>单片机的结构及结构间的关系如下图所示。</p>

<p><img src="/images/post/scm-principle-1_3.png" alt="单片机的结构及结构间的关系" width="450pt" /></p>

<ol>
  <li>
    <p>运算单元：可以从输入单元或是记忆单元提取数据，还可以将数据输送到输出或是记忆单元</p>

<script type="math/tex; mode=display">\mbox{运算单元}\left\{\begin{array}{l}
\mbox{算术运算：加减乘除等}\\
\mbox{逻辑运算：与或非等}
\end{array}\right.</script>
  </li>
  <li>控制单元：协调各部分之间的工作，使单片机按照编写的程序逐步执行。在执行一条命令的时候，单片机先解码，了解意思后再执行，一条条命令逐一执行，知道命令结束。</li>
  <li>输入与输出单元：单片机上只提供了I/O口，具体输入输出设备是什么，如何驱动使其工作，就需要自己电路设计和软件编程了，这应该是与普通编程最大的区别了</li>
  <li>
    <p>记忆单元：</p>

<script type="math/tex; mode=display">\mbox{记忆单元}\left\{\begin{array}{l}
\mbox{主记忆体}：\left\{\begin{array}{l}
\mbox{ROM}\\
\mbox{RAM}
\end{array}\right.\\
\mbox{辅助记忆体}
\end{array}\right.</script>

    <ul>
      <li>ROM：只读内存，可以理解为存储程序的地方，在单片机运行期间只可以读取，不可以写入。存储的内容断电不会丢失</li>
      <li>RAM：随机存取存储器，在单片机运行期间可读可写，但是保存的内容断电就消失</li>
      <li>辅助记忆体：单片机的外设记忆体，例如硬盘之类的，在地址（“地址”在<a href="/blog/scm-principle-2.html">下一章</a>中具体介绍）允许范围内可以无限扩充</li>
    </ul>
  </li>
</ol>

<h3 id="section-2">8051单片机结构</h3>

<p>上面介绍的是笼统的单片机结构，无论是我们将介绍的8051还是ipad的A5芯片都是这个样子的。现在要具体介绍8051单片机的更具体的结构</p>

<p><img src="/images/post/scm-principle-1_5.png" alt="8051单片机结构" width="550pt" /></p>

<p>这其中的具体词汇可能还不了解，但是不要紧，后面章节会提到，到时候再来看就明白了</p>

<h3 id="section-3">8051单片机引脚图</h3>

<p><img src="/images/post/scm-principle-1_6.png" alt="8051单片机结构" width="350pt" /></p>

<p>上图是标准Intel的8051芯片引脚图，对于不同厂家的不同型号，不同之处就是引脚的排列顺序和I/O口的数量（I/O口就是”Px.x”的引脚）</p>

<p>各个引脚的功能如下：</p>

<ol>
  <li>
    <p>P0 ~ P3：I/O口。注意：P0口本身不具有提升电路，需要外接提升电路来提供足够的电压给被控制元件。提升电路如图：</p>

    <p><img src="/images/post/scm-principle-1_9.jpg" alt="提升电路" width="350pt" /></p>

    <p>电阻大小需要具体情况具体分析。也可直接连接driver chip，再连接被控制元件。</p>
  </li>
  <li>Vcc：电源。GND：接地。</li>
  <li>EA：控制是否读取外部程式记忆体。为低时，读取；为高时，不读取</li>
  <li>ALE：位置锁住置能。平常每个时钟周期都会出现。如果此处接外部电路，则可以认为是外部时脉</li>
  <li>PSEN：外部程式记忆体读取信号</li>
  <li>RXD：串列传输输入端</li>
  <li>TXD：串列传输输出端</li>
  <li>INT0与INT1：外部中断输入端</li>
  <li>T0与T1：计数器外部输入端</li>
  <li>RD：外部资料记忆体读取激发信号</li>
  <li>WR：外部资料记忆体写入激发信号</li>
  <li>XTAL1与XTAL2：反向振荡器输入与输出端。与内部时脉结合形成时钟电路。</li>
</ol>

<h3 id="section-4">单片机最小系统</h3>

<p>单片机本身是无法直接工作的，需要最小系统的支持才能正常工作，最小系统包括三部分电路：</p>

<ol>
  <li>电源：不同型号，需要的电压不同，一般8051是+5V。Vcc引脚接+5V，GND引脚接地。</li>
  <li>
    <p>时钟电路：单片机需要一个可以震荡的电路，为其产生一个震荡频率稳定的时钟信号来计时，从而同步各部分的工作。一般的8051已经集成了振荡电路，需要我们提供晶振给这个振荡电路稳定的振荡频率，连接方法如图。有的型号的8051系列单片机可能连外部晶振都不需要，自己就可以产生稳定的时钟信号，例如<a href="https://www.silabs.com/Support%20Documents/TechnicalDocs/C8051F34x.pdf">C8051f340</a>。</p>

    <p><img src="/images/post/scm-principle-1_7.png" alt="时钟电路" width="300pt" /></p>

    <p>如果需要12MHz，就将晶振换为12MHz，两个电容换为30pF</p>
  </li>
  <li>
    <p>复位电路：复位电路使单片机除了ROM的内容全部恢复到初始状态。电路（RST就是单片机的RST引脚）如下，这个电路断电自动复位，并且还有按钮可以在运行期间复位。</p>

    <p><img src="/images/post/scm-principle-1_8.png" alt="复位电路" width="300pt" /></p>
  </li>
</ol>
]]></content>
  </entry>
  
</feed>
