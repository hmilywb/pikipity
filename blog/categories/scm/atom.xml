<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[categories: SCM | 折腾来折腾去]]></title>
  <link href="http://pikipity.github.com/blog/categories/scm/atom.xml" rel="self"/>
  <link href="http://pikipity.github.com/"/>
  <updated>2013-01-30T00:00:00+08:00</updated>
  <id>http://pikipity.github.com/</id>
  <author>
    <name><![CDATA[pikipity]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[单片机原理及程序设计 第四章 汇编语言]]></title>
    <link href="http://pikipity.github.com/blog/assembly-language.html"/>
    <updated>2013-03-07T20:39:00+08:00</updated>
    <id>http://pikipity.github.com/blog/assembly-language</id>
    <content type="html"><![CDATA[<p>学习汇编语言可以很好地帮助单片机的学习，而且一个好的汇编语言写成的程序要比实现相同功能的 C 语言更短更快。但是难以理解，移植性差，所以现在一般都用 C 语言来为单片机编程，只有部分硬件的驱动或是 C 语言难以控制的部分来用汇编编写。</p>

<h2 id="section">汇编指令分类</h2>

<p>汇编语言中的指令分为两大部分：</p>

<ol>
  <li>指令（Instruction）：指令会被编译器编译为机器语言将来提供给单片机。指令的数量很有限，不像 C 语言，内置函数就一堆，所以用到什么查表就可以了，表格会在后面提供。</li>
  <li>伪指令（Direction）：伪指令不会被编译器编译为机器语言，仅仅是提供给编译器，为了“编译”而存在的指令。</li>
</ol>

<h2 id="section-1">汇编语言格式</h2>

<p>任何编程语言都有格式，汇编语言也不例外，格式如下：</p>

<pre><code>标记: 操作码 操作数  ;注释
</code></pre>

<p>标记不是每一行都有，需要的时候有就可以了，标记是为了方便对程序内存的寻址，冒号是和标记一起存在的。操作码和操作数就是汇编指令，当然必须有。分号与注释一起存在，不会被编译。</p>

<h2 id="section-2">寻址方式</h2>

<p>再给出所有汇编指令表之前先要介绍一下汇编语言的寻址方式，单片机中对数据的操作最常见的就是将数据从内存的一个地方移到另一个地方，在移动的过程中就需要声明内存地址（内存地址是什么？请回到<a href="http://pikipity.github.com/blog/scm-principle-2.html">第二章</a>，谢谢），那么如何获得这个内存地址呢？就是通过“寻址”来获得。8051 的汇编指令只有四种寻址方式：</p>

<ol>
  <li>直接寻址（Direct Addressing，在表格中简写为 Dir）：直接给出一个16进制数，代表资料记忆体的一个字节地址，从这个地址中拿出数据来操作。只能用于内置 RAM</li>
  <li>间接寻址（Indirect Addressing，在表格中简写为 Ind）：一个 “@” 的符号在加一个寄存器的名字，例如 <code>@DPTR</code>，从这个寄存器中拿出数据，把这个数据当做地址，再从这个地址中拿出数据来操作。可对内置和外扩 RAM 使用。</li>
  <li>寄存器寻址（Register Addressing，在表格中简称 Reg）：直接一个寄存器的名字，例如 <code>R0</code>，从寄存器中拿出数据进行操作。仅对寄存器有效。</li>
  <li>立即寻址（Immediate Addressing，在表格中简称 Imm）：一个井号 “#” 再加一个整数，例如 <code>#1011B</code>，直接对这个整数进行操作。</li>
</ol>

<h2 id="section-3">指令表</h2>

<p>为了方便记忆和查询，指令又分为了五类</p>

<ol>
  <li>
    <p>数据移动：数据移动的指令又根据被移动的数据所在位置分为三个部分。</p>

    <ul>
      <li>
        <p>内部 ROM 内数据的移动</p>

        <p><img src="/images/post/MOV.jpg" width="550pt" /></p>
      </li>
      <li>
        <p>外部 ROM 内数据读取与写入</p>

        <p><img src="/images/post/MOVX.jpg" width="350pt" /></p>
      </li>
      <li>
        <p>程序内存数据读取</p>

        <p><img src="/images/post/MOVC.jpg" width="350pt" /></p>
      </li>
    </ul>

    <p>注意：</p>

    <ul>
      <li>Ri 的意思是 R1 或者 R0，不包括 R2 ~ R7</li>
      <li>
        <p>MOV 指令代表一个1 byte 的机器语言，所以它的操作数中不可能同时出现多个寄存器，例如 <code>MOV R0,R1</code> 是错误的，只能是</p>

        <pre><code>MOV A,R1
MOV R0,A
</code></pre>
      </li>
    </ul>
  </li>
  <li>
    <p>计算：</p>

    <p><img src="/images/post/MATH.jpg" width="550pt" /></p>
  </li>
  <li>
    <p>逻辑运算：</p>

    <p><img src="/images/post/ANL_A.jpg" width="550pt" /></p>
  </li>
  <li>
    <p>布尔运算和判断：</p>

    <p><img src="/images/post/ANL_C.jpg" width="350pt" /></p>
  </li>
  <li>
    <p>跳转：</p>

    <p><img src="/images/post/JUMP_1.jpg" width="550pt" /></p>

    <p><img src="/images/post/JUMP_2.jpg" width="350pt" /></p>
  </li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单片机原理及程序设计 第三章 数据类型与表示方法]]></title>
    <link href="http://pikipity.github.com/blog/scm-principle-3.html"/>
    <updated>2013-03-07T10:36:00+08:00</updated>
    <id>http://pikipity.github.com/blog/scm-principle-3</id>
    <content type="html"><![CDATA[<p>对 8051 的编程本质上就是对一个个二进制数在内存中运算和转移，所以明确各种进制（尤其是二进制、十进制和十六进制）在汇编中的表示方法和它们之间的转换方法就非常重要了。</p>

<h2 id="section">二进制</h2>

<p>无符号二进制的表示方法很简单，只要在你所要表示的二进制数后面加一个 <strong>“B”</strong> 就可以了。例如 <code>1011011B</code>。8位无符号整数范围为 0 ~ 255。16位无符号整数范围为 0 ~ 65535。</p>

<p>表示有符号二进制的时候，一个 Byte 8位中的最高位表示符号，1为负，0为正，后面7位是你要表示的数的绝对值。8位有符号整数范围为 -128 ~ 127。16位有符号整数范围为 -32768 ~ 32767。</p>

<p>当计算有符号二进制数加法的时候（减法只要转换一下加数的符号就变成加法了，所以是一样的），要先将负数变为2补数，然后再相加。所谓<strong>2补数</strong>，就是这个负数的<strong>绝对值</strong>的二进制数的<strong>反数加一</strong>。例如要求-96的2补数，96转换为二进制为01100000，先求反数为10011111，再加一就是-96的2补数10100000</p>

<h2 id="section-1">十进制</h2>

<p>十进制在汇编中的表示很简单，一个单纯的数（例如<code>129</code>）或是一个数字后面加一个 <strong>“D”</strong> （例如<code>129D</code>）就可以了。</p>

<p>从二进制到十进制有一种特殊的转换方法，就是BCD转换方法，先将二进制4位为一部分的分开然后在进行转化，下面的例子展示了如何进行转化。</p>

<p><img src="/images/post/scm-principle-3_1.jpg" alt="BCD转化举例" width="200pt" /></p>

<p>注意：BCD转化出来的一定是十进制，不要与16进制搞混，虽然看上去一样，但是表示的大小则完全不一样。</p>

<h2 id="section-2">十六进制</h2>

<p>十六进制从0到15分别为 <code>0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F</code></p>

<p>十六进制在汇编中只要在数的后面加一个 <strong>“H”</strong> 就可以了，例如 <code>2FH</code>。</p>

<p>需要注意的是，在汇编中，如果这个16进制数的第一个数就是一个字母的话需要在字母前加一个 <strong>“0”</strong>，例如 <code>0FEH</code>。</p>

<h2 id="section-3">小数</h2>

<p>上面介绍的都是整数，小数的表示则比较复杂。小数分为定点小数和浮点小数。</p>

<h3 id="section-4">定点小数</h3>

<p>定点小数的小数位数是固定的，定点小数表示简单，我们可以随意设定自己这个程序里面小数定点小数的表示方法，比如，我们可以规定我们的小数为8位，小数点前的数为7位，最前面还有一个符号位，那么我们的小数就表示如下图所示：</p>

<p><img src="/images/post/scm-principle-3_2.jpg" alt="定点小数表示" width="250pt" /></p>

<p>定点小数的好处是表示简单、计算方便。缺点也很明显，无法表示拥有很多的小数位数的数，所以我们需要浮点小数。</p>

<h3 id="section-5">浮点小数</h3>

<p>浮点小数的小数为不固定，而是用科学计数法的方式记录小数，一个浮点小数分为三部分：符号位 S、阶码位 P 和尾数为 M，所标表示意思如下：</p>

<script type="math/tex; mode=display">(-1)^S\times M\times 2^P</script>

<p>浮点小数又分为单精度浮点和双精度浮点：</p>

<ol>
  <li>单精度浮点的阶码为8位，位数为23位，共32位（即四个字节）。</li>
  <li>双精度浮点的阶码为11位，位数为52位，共64位（即八个字节）。</li>
</ol>

<p>由于双精度和单精度除了长度以外都相同，所以这里只介绍单精度，双精度请自行脑补。</p>

<p>单精度浮点数表示格式如下：</p>

<table>
  <tbody>
    <tr>
      <td>S（第31位）</td>
      <td>P（30位到23位）</td>
      <td>M（22为到0位）</td>
    </tr>
  </tbody>
</table>

<p>根据 IEEE 754 的标准，浮点小数有三种特殊情况：</p>

<ol>
  <li>P 和 M 都为全0的时候，表述0</li>
  <li>P 为全1，M 为全0的时候，表示无穷大，符号位确定正负</li>
  <li>P 和 M 都为全1的时候，表示“这不是一个数”</li>
</ol>

<p>也就是说，单浮点最大为 <code>0 11111110 11111111111111111111111</code>，也就是 3.40282346638529E+38，最小为 <code>1 11111110 11111111111111111111111</code>，也就是 -3.40282346638529E+38，最接近0的数是 <code>0 00000000 00000000000000000000001</code>，也就是 1.40129846432482E-45。</p>

<h2 id="section-6">二进制单精度浮点小数转化为十进制方法</h2>

<p>将单精度浮点小数转化为十进制比较简单，只要按照对应的部分转化就可以得到对应的十进制数了，转化规律如：</p>

<ol>
  <li>符号位：0为正，1为负。</li>
  <li>阶码位：对应的十进制减127（双浮点减1023）。例如阶码位为 <code>10001010</code> ，那么对应的2的指数就是 $138-127=11$。</li>
  <li>尾数位：在尾数位的最左边补一个1，将小数点放在这个1的后面，进行转化，所得到的就是尾数了。例如，尾数位为 <code>01110101100011100010001</code>，那么对应的尾数就是 $1.4592$</li>
  <li>
    <p>按照公式组合就可以了，这里公式再次给出一边：</p>

<script type="math/tex; mode=display">(-1)^S\times M\times 2^P</script>
  </li>
</ol>

<h2 id="section-7">十进制小数转化为二进制单精度浮点的方法</h2>

<p>将十进制转化为单浮点二进制就比较麻烦了，可以按照下面的方法：</p>

<ol>
  <li>符号位就不说了，主要是计算阶码位和尾数位。首先判断要转化的十进制是不是纯小数（纯小数的意思是无整数部分），如果是就到第三步，如果不是继续到第二步</li>
  <li>
    <p>不是纯小数，就可以把数字分为两部分，整数部分和小数部分，整数部分就按照普通的方法转换就可以了，小数部分可以通过下面的方法转换：</p>

    <p><img src="/images/post/scm-principle-3_3.jpg" alt="十进制小数部分转化方法" width="350pt" /></p>

    <p>然后将转化出来的二进制数的小数部分和整数部分组合在一起，左移小数点直到整数部分只剩一个1为止，小数部分取左起23位就是尾数位，将小数点移动的位数加127，转化为二进制就是阶码位。</p>
  </li>
  <li>
    <p>如果是纯小数就要先将纯小数转化为 <script type="math/tex">1.\cdots\times 2^n</script> 的形式，可以通过下面的公式转化（公式中 $X$ 代表待转换的十进制纯小数）：</p>

<script type="math/tex; mode=display">n=\mbox{int}(log_2 X-1)</script>

    <p>然后将转化之后的小数部分按照步骤2中方法进行转化，结果取左起23位就是尾数为，$n+127$ 转化为二进制就是阶码位。</p>
  </li>
</ol>

<p>为了方便大家进行二进制、十进制和十六进制之间的转换，我用 Python 编写了一个小程序，下载在<a href="http://pikipity.github.com/Binary-Converter/">这里</a>，如果发现有什么 Bug，欢迎指正，谢谢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单片机原理及程序设计 第二章 记忆体和寄存器]]></title>
    <link href="http://pikipity.github.com/blog/scm-principle-2.html"/>
    <updated>2013-02-27T22:37:00+08:00</updated>
    <id>http://pikipity.github.com/blog/scm-principle-2</id>
    <content type="html"><![CDATA[<p><a href="http://pikipity.github.com/blog/scm-principle-1.html">上一章</a>主要是简单介绍了一下 8051 的样子和结构，这一章主要介绍内存，为将来介绍各个特殊功能和 assembly 做准备。</p>

<h3 id="section">记忆体种类</h3>

<p>记忆体主要分为两种：</p>

<ol>
  <li>只读记忆体（ROM）：资料一旦存储就不能删除或是修改（既不能重新写入），且内容不会因为断电而消失。一般来说，我们可以认为你所编写的程式就存储在 8051 的 ROM 中，当然现在的新科技已经允许通过一定的手段来从新修改 ROM 上的内容了，所以你可以向你的 8051 芯片中重新写入程式，但是重新写入的次数是有限，但是这个次数非常大，所以不用担心。8051 内部 ROM 容量为 4K Byte，最大可扩充到 64K Byte。8052 内部 ROM 容量为 8K Byte，最大可扩充到 64K Byte</li>
  <li>随即存储存储器（RAM）：可以随时将数据存入记忆体的任意位置，但是断电后数据会消失。一般来说，我们可以认为程式临时数据就是存储在 8051 的 RAM 中的。8051 内部 RAM 容量为 128 Byte，最大可扩充到 64K Byte。8052 内部 RAM 容量为 256 Byte，最大可扩充到 64K Byte。</li>
</ol>

<!--more-->

<h3 id="section-1">地址分配</h3>

<p>我们不可能随意的将数据存储在记忆体中，如果那样的话，我们就难以知道自己所需的数据到底存储在哪里，所以我们用“地址”来对记忆体中的数据定位。我们一般用一个十六进制数<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 来表示一个地址。程式记忆体（可以理解为 ROM）和资料记忆体（可以理解为 RAM）的地址是分开的。</p>

<ol>
  <li>程式记忆体地址分配：由于 8051 允许外部扩充程式记忆体，所以程式记忆体的地址分配有两种（以下程式记忆体的地址都是一个地址代表一个字节（8位二进制））：
    <ul>
      <li>
        <p>EA 引脚接高时：</p>

        <p><img src="/images/post/scm-principle-2-1.jpg" alt="当 EA 接高时，程式记忆体的地址分配" width="350pt" /></p>
      </li>
      <li>
        <p>EA 引脚接地时：</p>

        <p><img src="/images/post/scm-principle-2-2.jpg" alt="当 EA 接地时，程式记忆体的地址分配" width="350pt" /></p>
      </li>
    </ul>
  </li>
  <li>资料记忆体地址分配：资料记忆体的地址（依然是一个地址代表一个字节（8位二进制））从 00H 到 FFH，共分为四个部分：
    <ul>
      <li>
        <p>00H ~ 1FH：四个寄存器组。由于在写 assembly 程序的时候，每次都记住地址很麻烦，所以 assembly 为一部分地址直接预设了名字，这样我们就可以直接通过调用名字来使用这一部分内存而不是记住地址。这四个寄存器组 RB0~RB3 中，每个寄存器组又包含8个8位寄存器 R0~R7（每个字节地址就是一个寄存器），主要用来存放数据。但每次只能使用一个寄存器组，通过 RS0 和 RS1 两个位元来控制到底使用哪个寄存器组：</p>

        <table>
          <thead>
            <tr>
              <th style="text-align: center">RS1</th>
              <th style="text-align: center">RS0</th>
              <th style="text-align: center">寄存器组</th>
              <th style="text-align: center">位置</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="text-align: center">0</td>
              <td style="text-align: center">0</td>
              <td style="text-align: center">RB0</td>
              <td style="text-align: center">00H~07H</td>
            </tr>
            <tr>
              <td style="text-align: center">0</td>
              <td style="text-align: center">1</td>
              <td style="text-align: center">RB1</td>
              <td style="text-align: center">08H~0FH</td>
            </tr>
            <tr>
              <td style="text-align: center">1</td>
              <td style="text-align: center">0</td>
              <td style="text-align: center">RB2</td>
              <td style="text-align: center">10H~17H</td>
            </tr>
            <tr>
              <td style="text-align: center">1</td>
              <td style="text-align: center">1</td>
              <td style="text-align: center">RB3</td>
              <td style="text-align: center">18H~1FH</td>
            </tr>
          </tbody>
        </table>
      </li>
      <li>20H ~ 2FH：可位元寻址区，这一部分的地址都允许直接对 bit 进行操作。例如，21H.0 就代表在字节地址 21H 的8位二进制的第 0 位。</li>
      <li>30H ~ 7FH：一般数据与堆栈区。不可以位元寻址，就是一般的存储数据的地方</li>
      <li>
        <p>80H ~ FFH：特殊功能寄存器（SFR）。8051 本事已经内置了很多的功能，在<a href="http://pikipity.github.com/blog/scm-principle-1.html">第一章</a>的8051单片机结构中就可以看到，有计时/计数器、中断、UART串口等等，这些特殊功能需要通过设置这一部分的 SFR 的参数来控制。在讲解各个特殊功能的时候会讲解如何设置参数，和这些参数代表什么意思。下面是一幅AT89系列的 SFR 地址分配表，将来可以对照、理解。</p>

        <p><img src="/images/post/scm-principle-2-3.jpg" alt="AT89系列的 SFR 地址分配表" width="550pt" /></p>

        <p>注意：</p>

        <ul>
          <li>注意最左边一列都可以位元寻址</li>
          <li>括号中的寄存器代表 AT89C52 才有，AT89C51 没有</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>十六进制数就是以逢16进1作为进位制的数，一般用数字0到9和字母A到F表示，并在数后面加一个“H”来表示此数为16进制。<a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Proteus和Keil的简单教程]]></title>
    <link href="http://pikipity.github.com/blog/keil-and-proteus.html"/>
    <updated>2013-02-16T21:38:00+08:00</updated>
    <id>http://pikipity.github.com/blog/keil-and-proteus</id>
    <content type="html"><![CDATA[<p>这篇主要简单介绍一下单片机仿真软件Proteus和单片机编程软件Keil，方便各位读者能够快速的在自己电脑上搭建一个8051单片机的软件仿真平台。</p>

<h3 id="proteus">单片机仿真软件 – Proteus</h3>

<p>如果你在平时的电路仿真中稍微留意一下的你会发现<a href="http://baike.baidu.com/view/1867313.htm">Spice</a>在仿真中都无法仿真单片机系统，所以这里需要介绍一下这个单片机仿真软件<a href="http://baike.baidu.com/view/40936.htm">Proteus</a>。由英国<a href="http://www.labcenter.com/index.cfm">Labcenter electronics公司</a>出品的<a href="http://baike.baidu.com/view/5822.htm">EDA软件</a>，可以很好的仿真一部分单片机及其外围器材。并具有自动布线和智能生成原理图的功能。</p>

<!--more-->

<p>大家可以到<a href="http://pan.baidu.com/share/link?shareid=345198&amp;uk=4080321956">这里</a>下载Proteus Pro v7.8，压缩包内带有序列号生成器，并有安装及破解说明文件，虽然版本比较老，但是亲测可用。</p>

<p>下载并安装完成后，点击<img src="/images/post/proteus.png" width="50pt" />打开ISIS仿真软件，界面如下</p>

<p><img src="/images/post/proteus_1.jpg" alt="Proteus仿真界面" width="650pt" /></p>

<p>接下来介绍几点比较重要的使用方法，如果想要更详细一点的教程的话，可以到<a href="http://pan.baidu.com/share/link?shareid=354817&amp;uk=4080321956">这里</a>下载</p>

<ol>
  <li>
    <p>添加元件方法：在图纸范围内单机鼠标右键，打开菜单，”Place”中就是可以放置的元件。单片机及外围元件在Component -&gt; From Libraries中搜索就可以了。</p>

    <p><img src="/images/post/proteus_menu.jpg" alt="右键菜单" width="300pt" /></p>

    <p><img src="/images/post/proteus_menu_place.jpg" alt="Place菜单" width="450pt" /></p>

    <p><img src="/images/post/library.jpg" alt="Place -&gt; Component -&gt; From Libraries" width="550pt" /></p>

    <p>如果需要电源和地，则从Terminal中选择POWER或是GND就可以了，系统会根据你选则的单片机自动匹配POWER的电压大小（注意仿真的时候单片机本身不用接<a href="/blog/scm-principle-1.html">电源电路和时钟电路</a>），如果需要更改POWER电压值，只要右键单击POWER，选择”Edit Properties”，在”String”中输入你需要的电压值就可以了。</p>

    <p><img src="/images/post/terminal.jpg" alt="Terminal菜单" width="450pt" /></p>

    <p><img src="/images/post/POWER.jpg" alt="右键单击POWER元件" width="400pt" /></p>

    <p><img src="/images/post/POWER_edit.jpg" alt="Edit Properties" width="400pt" /></p>
  </li>
  <li>
    <p>连线方法：连线有三种方法，</p>

    <ul>
      <li>
        <p>直接连线：用鼠标点击两个节点便会自动连接。注意：当端口对齐的时候，只要连好最上面的第一条线，下面的线只要双击节点就可以自动连接，基本原理就是重复你的上一次动作。</p>

        <p><img src="/images/post/direct_connect.jpg" alt="直接连线的效果" width="550pt" /></p>
      </li>
      <li>
        <p>间接连线：通过右键菜单中的Terminal中的INPUT和OUTPUT连结两个节点。注意：对应的IMPUT和OUTPUT需要有一样的名字，起名字的方法和编辑POWER电压值的方法一样。</p>

        <p><img src="/images/post/indirect_connect.jpg" alt="间接连线的效果" width="550pt" /></p>
      </li>
      <li>
        <p>使用BUS连线：在左侧工具栏选择BUS <img src="/images/post/BUS.jpg" width="50pt" />，就可以画出蓝色BUS线了，注意转折的地方需要点一下鼠标，结束双击鼠标。画完BUS线后，将节点连到BUS线上，然后对BUS设置Label,方法是右键单击BUS线，选择“Place Wrie Label”，Label的输入方式类似于下面效果图，意思是生成A1到A3的Label。再将对应节点的连线改为一样的名字，改名字的方法，和BUS线加Label的方法一样。注意：连线的名字不用一个个输入了，由于之前的BUS已经生成了Label，只要在下拉框内选择就可以了。</p>

        <p><img src="/images/post/BUS_connect.jpg" alt="BUS连线效果图" width="550pt" /></p>
      </li>
    </ul>
  </li>
  <li>
    <p>向单片机内加载生成的Hex文件的方法：左键双击单片机，在”Program File”一栏里填入Hex文件的路径或点击后面文件夹选择Hex文件，”OK”即可。在这个窗口还可以改变时钟周期，在”Clock Frequency”中修改。</p>

    <p><img src="/images/post/doube_click_scm.jpg" alt="左键双击单片机" width="400pt" /></p>
  </li>
</ol>

<h3 id="keil">51系列单片机编程软件 – Keil</h3>

<p><a href="http://baike.baidu.com/view/942051.htm">Keil</a>是美国<a href="http://www.keil.com/">Keil software公司（已被ARM收购）</a>出品的专为51系列单片机进行编程的软件，可以编译C语言和汇编语言，其C语言的编译器Keil C51已经成为一种类似于行业标准一样的存在了。</p>

<p>可以到<a href="http://pan.baidu.com/share/link?shareid=354882&amp;uk=4080321956">这里</a>下载Keil uVision3，或者到<a href="http://www.doyoung.net/data.html">杜洋工作室</a>下载。</p>

<p>下载并安装后，就可以通过<img src="/images/post/keil.png" width="50pt" />打开了。打开后界面如下图。每次打开都会自动回复上次关闭前最后一次保存的Project。</p>

<p><img src="/images/post/keil_1.jpg" alt="Keil uVision3 界面" width="650pt" /></p>

<p>建立一个Project一般分为如下几步：</p>

<ol>
  <li>
    <p>在菜单栏上选择 Prject -&gt; New Project，并起名字和保存。</p>

    <p><img src="/images/post/new_project.jpg" alt="New Project" width="650pt" /></p>

    <p><img src="/images/post/projectname.jpg" alt="Project起名、保存" width="650pt" /></p>
  </li>
  <li>
    <p>选择单片机类型。注意：确定后，会弹出对话框询问是否自动添加启动文件到Project中，一般选择“No”就可以了，因为由Keil提供的单片机启动文件在初学阶段一般不会用到</p>

    <p><img src="/images/post/scmstyle.jpg" alt="选择单片机类型" width="650pt" /></p>

    <p><img src="/images/post/startup.jpg" alt="是否添加启动文件" width="450pt" /></p>
  </li>
  <li>
    <p>然后新建一个文件开始编写C或者汇编。注意：保存的时候需要提供后缀名，如C的后缀为.c，汇编的后缀为.asm</p>

    <p><img src="/images/post/newfile.jpg" alt="新建文件" width="650pt" /></p>

    <p><img src="/images/post/filename.jpg" alt="保存文件（注意文件名）" width="650pt" /></p>
  </li>
  <li>
    <p>右键单击Project的文件夹，选择”Add Files to Group”，选择你的文件，“OK”，就可以将文件加入到project中</p>

    <p><img src="/images/post/addtogroup.jpg" alt="将文件加入到project中" width="650pt" /></p>
  </li>
  <li>
    <p>编译的时候，只要按工具栏上的<img src="/images/post/buildall.jpg" width="50pt" />就可以编译了。如果需要生成Hex文件用来烧录或是仿真，就需要在编译前按工具栏上的<img src="/images/post/projectproperty.jpg" width="50pt" />，选中”Output”中的”Creat HEX”就可以了。</p>

    <p><img src="/images/post/creathexornot.jpg" alt="生成Hex选项" width="650pt" /></p>
  </li>
</ol>

<p>有了这两个软件，大家就可以进行单片机从硬件到软件的软件仿真了，但是仿真永远是仿真，不代表实物就是如此，所以真正实际是什么样子，还是硬件仿真比较靠谱。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[单片机原理及程序设计 第一章 单片机简介]]></title>
    <link href="http://pikipity.github.com/blog/scm-principle-1.html"/>
    <updated>2013-02-08T23:47:00+08:00</updated>
    <id>http://pikipity.github.com/blog/scm-principle-1</id>
    <content type="html"><![CDATA[<p>这个《单片机原理及程序设计》系列主要是简单介绍8051系列单片机的基本原理及功能，并附带一些小程序作为应用的范例，为了便于程序理解，大多程序以C的形式出现，但是也会包括一部分的汇编，因为汇编是用来学习单片机结构与原理的最好语言了。这个系列主要抄录自<a href="http://elearning.stut.edu.tw/mechelec/chip.htm">《單晶片原理與程式設計》</a>，<a href="http://elearning.stut.edu.tw/mechelec/chip.htm">《單晶片原理與程式設計》</a>虽然介绍得已经很全面了，但是由于过于简略，以至于一个新手如果只看这一份材料很难明白它在说什么，所以这里作进一步的归纳、总结和补充。</p>

<h3 id="section">什么是单片机</h3>

<p><img src="/images/post/scm-principle-1_1.png" alt="单片机 AT89C51" width="300pt" /></p>

<!--more-->

<p>上面这幅图就是8051系列的一种单片机AT89C51了，是的，单片机就是一块芯片而已，但是这块芯片里面可以说是包含了大半个你用的PC机或是ipad吧。需要注意的是，下面这幅图是单片机学习板，不要再指着整块学习板说是单片机了，学习板包是一整套完整的电路，包含了你要学习的原件，只要将单片机插入到上面，正确编程就可以使用了，使初学者专注于编程学习，可以忽略掉复杂的电路设计部分。但是单片机的编程是硬件编程（在后面的编程部分你就能深刻的体会到硬件编程和平常的编程有什么不同了），硬件部分的学习是绝对不可以忽略的。所以我建议，学习单片机不要只是编程，有条件，就买实体元件，自己搭建电路，可以学习的更加透彻，没有条件，可以下载仿真程序，例如<a href="http://baike.baidu.com/view/40936.htm">Proteus</a>(<a href="http://pan.baidu.com/share/link?shareid=345198&amp;uk=4080321956">点我下载Proteus</a>)。<a href="http://baike.baidu.com/view/40936.htm">Proteus</a>是一个简单易用的可以仿真单片机系统的软件，里面包含了大部分的8051系列芯片，和大量的常用原件，有了这个“妈妈再也不用花钱给我买学习版了”  o(≧v≦)o~~</p>

<p><img src="/images/post/scm-principle-1_2.png" alt="开发板" width="300pt" /></p>

<p>对单片机有了实感接触以后，就可以开始单片机的学习了</p>

<h3 id="section-1">单片机结构</h3>

<p>这部分其实是废话，因为如果不准备做单片机开发，太过深入了解单片机结构根本就没有什么用，但是话又说回来，如果一点都不了解的话，对于初学者心里又不踏实，总而言之还是需要了解的，仅仅是了解而已。</p>

<p>单片机的结构及结构间的关系如下图所示。</p>

<p><img src="/images/post/scm-principle-1_3.png" alt="单片机的结构及结构间的关系" width="450pt" /></p>

<ol>
  <li>
    <p>运算单元：可以从输入单元或是记忆单元提取数据，还可以将数据输送到输出或是记忆单元</p>

<script type="math/tex; mode=display">\mbox{运算单元}\left\{\begin{array}{l}
\mbox{算术运算：加减乘除等}\\
\mbox{逻辑运算：与或非等}
\end{array}\right.</script>
  </li>
  <li>控制单元：协调各部分之间的工作，使单片机按照编写的程序逐步执行。在执行一条命令的时候，单片机先解码，了解意思后再执行，一条条命令逐一执行，知道命令结束。</li>
  <li>输入与输出单元：单片机上只提供了I/O口，具体输入输出设备是什么，如何驱动使其工作，就需要自己电路设计和软件编程了，这应该是与普通编程最大的区别了</li>
  <li>
    <p>记忆单元：</p>

<script type="math/tex; mode=display">\mbox{记忆单元}\left\{\begin{array}{l}
\mbox{主记忆体}：\left\{\begin{array}{l}
\mbox{ROM}\\
\mbox{RAM}
\end{array}\right.\\
\mbox{辅助记忆体}
\end{array}\right.</script>

    <ul>
      <li>ROM：只读内存，可以理解为存储程序的地方，在单片机运行期间只可以读取，不可以写入。存储的内容断电不会丢失</li>
      <li>RAM：随机存取存储器，在单片机运行期间可读可写，但是保存的内容断电就消失</li>
      <li>辅助记忆体：单片机的外设记忆体，例如硬盘之类的，在地址（“地址”在<a href="/blog/scm-principle-2.html">下一章</a>中具体介绍）允许范围内可以无限扩充</li>
    </ul>
  </li>
</ol>

<h3 id="section-2">8051单片机结构</h3>

<p>上面介绍的是笼统的单片机结构，无论是我们将介绍的8051还是ipad的A5芯片都是这个样子的。现在要具体介绍8051单片机的更具体的结构</p>

<p><img src="/images/post/scm-principle-1_5.png" alt="8051单片机结构" width="550pt" /></p>

<p>这其中的具体词汇可能还不了解，但是不要紧，后面章节会提到，到时候再来看就明白了</p>

<h3 id="section-3">8051单片机引脚图</h3>

<p><img src="/images/post/scm-principle-1_6.png" alt="8051单片机结构" width="350pt" /></p>

<p>上图是标准Intel的8051芯片引脚图，对于不同厂家的不同型号，不同之处就是引脚的排列顺序和I/O口的数量（I/O口就是”Px.x”的引脚）</p>

<p>各个引脚的功能如下：</p>

<ol>
  <li>
    <p>P0 ~ P3：I/O口。注意：P0口本身不具有提升电路，需要外接提升电路来提供足够的电压给被控制元件。提升电路如图：</p>

    <p><img src="/images/post/scm-principle-1_9.jpg" alt="提升电路" width="350pt" /></p>

    <p>电阻大小需要具体情况具体分析。也可直接连接driver chip，再连接被控制元件。</p>
  </li>
  <li>Vcc：电源。GND：接地。</li>
  <li>EA：控制是否读取外部程式记忆体。为低时，读取；为高时，不读取</li>
  <li>ALE：位置锁住置能。平常每个时钟周期都会出现。如果此处接外部电路，则可以认为是外部时脉</li>
  <li>PSEN：外部程式记忆体读取信号</li>
  <li>RXD：串列传输输入端</li>
  <li>TXD：串列传输输出端</li>
  <li>INT0与INT1：外部中断输入端</li>
  <li>T0与T1：计数器外部输入端</li>
  <li>RD：外部资料记忆体读取激发信号</li>
  <li>WR：外部资料记忆体写入激发信号</li>
  <li>XTAL1与XTAL2：反向振荡器输入与输出端。与内部时脉结合形成时钟电路。</li>
</ol>

<h3 id="section-4">单片机最小系统</h3>

<p>单片机本身是无法直接工作的，需要最小系统的支持才能正常工作，最小系统包括三部分电路：</p>

<ol>
  <li>电源：不同型号，需要的电压不同，一般8051是+5V。Vcc引脚接+5V，GND引脚接地。</li>
  <li>
    <p>时钟电路：单片机需要一个可以震荡的电路，为其产生一个震荡频率稳定的时钟信号来计时，从而同步各部分的工作。一般的8051已经集成了振荡电路，需要我们提供晶振给这个振荡电路稳定的振荡频率，连接方法如图。有的型号的8051系列单片机可能连外部晶振都不需要，自己就可以产生稳定的时钟信号，例如<a href="https://www.silabs.com/Support%20Documents/TechnicalDocs/C8051F34x.pdf">C8051f340</a>。</p>

    <p><img src="/images/post/scm-principle-1_7.png" alt="时钟电路" width="300pt" /></p>

    <p>如果需要12MHz，就将晶振换为12MHz，两个电容换为30pF</p>
  </li>
  <li>
    <p>复位电路：复位电路使单片机除了ROM的内容全部恢复到初始状态。电路（RST就是单片机的RST引脚）如下，这个电路断电自动复位，并且还有按钮可以在运行期间复位。</p>

    <p><img src="/images/post/scm-principle-1_8.png" alt="复位电路" width="300pt" /></p>
  </li>
</ol>
]]></content>
  </entry>
  
</feed>
